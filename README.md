# OrchidApp

OrchidApp is a learning and reference project for building a web application backed by a rigorously designed, validated, and version-controlled MySQL database schema.

The project deliberately treats the database schema as source code, with strict guarantees that:

- Every committed schema can be rebuilt from scratch
- Schema drift is detected immediately
- Local development and CI behave the same way

This repository is intentionally opinionated and automation-heavy. The automation is the contract.

The web application layer is developed on top of this foundation and is the primary area of future work.

---

## Database Layer (MySQL)

### Core principles

1. **The live database schema is the authoritative source**  
   All schema changes are made in a database instance, not by editing SQL files.

2. **Schema files are generated artefacts**  
   Files under `database/schema/` are generated automatically and must never be edited manually.

3. **Git is the contract**  
   Anything committed to Git must be sufficient to rebuild the schema from scratch.

4. **Local validation mirrors CI**  
   What passes locally will pass in GitHub Actions, and vice versa.

---

### Mandatory setup (do this first)

After cloning the repository, you **must** run the setup script:

```powershell
pwsh scripts/setup.ps1
```

This step is not optional. It:

- verifies required tooling (PowerShell, Docker, MySQL client)
- configures Git to use the repository’s custom hooks (`.githooks/`)
- ensures schema validation runs automatically on every commit

Commits made without running this setup are invalid and will fail CI.

---

### Prerequisites (required)

The following applications and configuration are required to work on this repository. Commits and CI will fail if these requirements are not met.

#### Applications

- **PowerShell 7 or later** (`pwsh`)
- **Git**, with support for custom hooks via `core.hooksPath`
- **Docker Desktop** (or equivalent Docker runtime). Docker must be running before committing or running local CI
- **MySQL client tools**, compatible with the target MySQL major version
- **VS Code**, general editor and Git integration

#### Configuration

- Git must allow custom hooks (`core.hooksPath` is configured by `scripts/setup.ps1`)
- PowerShell execution policy must allow local script execution
- Docker must be available to the current user account

The setup script validates these prerequisites and will fail fast with clear errors if any are missing.

---

CI.

---

### Repository structure (high level)

- `database/schema/`  
  Generated SQL fragments representing the current database schema. **Do not edit manually.**

- `database/scripts/`  
  PowerShell scripts that export and assemble the schema in a deterministic way.

- `.githooks/pre-commit`  
  Enforces schema export and validation during every commit.

- `scripts/ci-local.ps1`  
  Runs the same schema build validation locally that CI runs in GitHub Actions.

---

### How schema changes work

1. Make schema changes directly in your local MySQL database
2. Commit your changes as normal
3. During commit, the pre‑commit hook will:
   - export the schema from the database
   - normalise and regenerate files under `database/schema/`
   - stage any updated schema files automatically
   - fail the commit if export or validation fails

The commit may modify files as part of this process. This is expected behaviour.

---

### Pre‑commit enforcement

The pre‑commit hook is a **hard gate**, not an advisory check.

- It mutates and stages generated schema files
- It prevents commits if schema export or validation fails
- Bypassing it (for example using `--no-verify`) is not permitted

Any commit that bypasses the hook will fail CI and be rejected.

### Database-only changes (important)

If you have made schema changes **only in the database**, Git may report that there are no file changes to commit.

This is expected.

In this project, schema files are generated by the **pre-commit hook**, not edited manually.  
Therefore, you must explicitly trigger a commit to allow the hook to run.

#### Required procedure

When you have database-only changes:

1. Open **Git Bash** in the repository root
2. Confirm you are on the correct branch:

   ```bash
   git branch --show-current
   ```
3. Execute the command to manually commit:

   ```bash
   git commit --allow-empty
   ```
4. When the editor opens:

- Enter a clear commit summary
- Optionally include a detailed description

5. Save and exit the editor

   The pre-commit hook will then:

   - Export the schema from the database
   - Regenerate files under database/schema/
   - Stage those files automatically
   - Complete the commit with the generated artefacts included

**Notes**

   - Do not use --no-verify
   - Do not manually edit generated files

GitHub Desktop cannot perform this step; Git Bash is required

---

### Local CI validation

Before opening a pull request, you are expected to run:

```powershell
pwsh scripts/ci-local.ps1
```

This script:

- spins up a disposable MySQL instance using Docker
- rebuilds the schema using only committed files
- mirrors the GitHub Actions workflow exactly

If this script fails locally, CI will fail as well.

---

### Continuous integration

GitHub Actions runs a schema build validation on every push and pull request.

CI does **not** use your development database. It validates that:

- the committed schema can be assembled
- the schema can be built from scratch
- no ordering or dependency issues exist

This ensures long‑term reproducibility and prevents schema drift.

---

## Web Application

OrchidApp is intended to be a web application backed by the MySQL database defined in this repository.

At present, development has deliberately focused on the database layer. The schema, constraints, and lifecycle rules are considered foundational and are treated as the primary source of truth. The web application layer is not yet implemented and should be considered an explicit gap rather than an omission.

The role of the web application is to:

- Act as the primary interface to the database
- Operate within the constraints enforced by the schema, not bypass them
- Provide workflow-driven interaction rather than generic CRUD screens
- Reflect the lifecycle and identification rules already modelled in the database

The web application is expected to evolve on top of the existing schema. Schema changes should be driven by clearly identified application needs, not speculative UI design.

No specific web framework, language, or stack is currently mandated. This is intentional. Architectural decisions for the application layer should follow the same principles applied to the database: clarity of responsibility, explicit constraints, and resistance to accidental complexity.

Development of the web application is the primary area of future work in this project.

---

### What this project is (and is not)

This project is:

- a learning and reference implementation
- deliberately strict by design
- focused on correctness and reproducibility

This project is not:

- optimised for rapid prototyping
- tolerant of undocumented manual steps
- flexible about bypassing validation

---

### Contributing

Please read `CONTRIBUTING.md` before making changes. It explains the expected workflow, validation requirements and commit rules in detail.

---

See `architecture.md for` the architectural philosophy behind these rules.